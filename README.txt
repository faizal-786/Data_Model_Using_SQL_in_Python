Hello, everybody,  So the code that I'm going through is in tracks.  It's got this library.xml file, which you can export from your, if you have iTunes, you can export this, or you can just play with my iTunes. And so this is also going to review how to read XML. So we're going to actually pull all this data. And this XML that Apple produces out of iTunes is a little weird, in that it's kind of key values, and so you see key value pairs. And it even uses the word dictionary. And so it's like, I'm going to make a dictionary that has this, then a dictionary within a dictionary. This, to me, could be so nice if it was JSON because it's really a list of dictionaries. This is a dictionary, then another dictionary, then another dictionary, and then the key for that dictionary. And it's a weird, weird format, but we'll write some Python to be able to read it. So you export that from iTunes, and you can use my file or you can use your file. It might be more fun to user your file. And so here's tracks.py, we're going to do some XML. And so we import that, we're going to import sqlite3 because we want to talk to the database. And then we're going to make a database connection. And in this, once we run this, you'll see that that file will exist. And so right now, if I'm in my tracks data, that file doesn't exist, but what we'll see is this is actually going to create it. Now, remember that we have a cursor, which is sort of like a file handle, it's really a database handle, as it were. And in order to sort of Bootstrap this nicely, we are going, because this code is going to run all the time, it's going to run and read all of library docs XML. In later things, we won't wipe out the database every time. And so I'm executing a script, which is a series of SQL commands separated by semicolons. So I'm going to throw away the artist table, album table, and track table, very similar to the stuff we covered in lecture. And then I'm going to do the create table, and I'm doing this all automatically. And you'll notice this is a triple-quoted string, so this is just one big, long string here. And it happens to know that it's SQL, thank you, Atom, for that. And so it creates all these things. Now, it's not quite as rich as the data model we built because there's no genres in here. And so it's artists, album, track, and then there's a foreign key for album ID and a foreign key for artist ID, which is sort of a subset of what we're doing. - so good luck :)

And so when that's done, that actually creates all the tables, and we'll see those in a moment once we run the code. Then it asks for a file name for the XML, right, and so that's what that is.

I wrote a function that does a lookup that, it's really weird because if you look at these files, like in this dictionary, there is a key, right? And so the key of this dictionary, this really could've should've been a key value pair.

And then we're going to lookup the name, artist, album, play count, rating, and total time, okay? And so here they are, play count, a lot of those things that we had in the sample lecture that I did. And we're going to look those things up, and we're going to do some sanity checking. If we didn't get a name, or an artist, or an album, we're going to continue. We're going to print them out. And then we are going to ask or get, remember how you have to get the primary key of a row so you can use it? So the way we're going to do this is we're going to do an insert or ignore. And so this or ignore basically says, because I said that the artist name, go up here, I said the artist name is unique. Which means if I try to attempt insert the same artist twice, it will blow up, okay? Because I put this constraint on that, except when I say insert or ignore that basically says, hey, If it's already there, don't insert it again. So what I'm doing here is insert or ignore into artist, so this is putting a new row into the artist table, unless there is already a row in that artist table.


